#include "A-star.hpp"
#include "opencv2/core/mat.hpp"
#include "opencv2/core/matx.hpp"
#include "opencv2/core/types.hpp"
#include <list>
#include <algorithm> // para std::sort

Astart::Astart(cv::Mat map) : Map_(map)
{
}

Astart::Astart(Astart &copy) : Map_(copy)
{
}

Astart::~Astart()
{
	std::cout << "end" << std::endl;
}


Astart &Astart::operator=(Astart &ret)
{
	return(*this);
}


auto  Astart::chek_points(cv::Point target)
{
	auto it = std::find_if(_open.begin(), _open.end(), [&](const t_node& node)
	{
			return node.point == target;  // compara x e y
	});
	if(it != _open.end())
		return (it);
	it = std::find_if(_close.begin(), _close.end(), [&](const t_node& node)
	{
			return node.point == target;  // compara x e y
	});
	
	return (it);

}

bool  Astart::chek_valid_point(t_node node)
{

	if(node.point.x > _map.rows || node.point.y > _map.cols || node.point.x < 0 || node.point.y < 0 )
		return (false);
	cv::Vec3i color= this->get_color(node.point);
	if(color[0] == 0  && color[1] == 0 && color[2] == 255)
		return (false);
	auto node_che = chek_points(node.point);
	if(node_che == _open.end() )
		return (true);	
	return (false);
}


double Astart::heuristic(cv::Point a, cv::Point b) {
    // Distância Manhattan
    return abs(a.x - b.x) + abs(a.y - b.y);
}


t_node Astart::create_node(cv::Point point, cv::Point prev, cv::Point goal)
{
    t_node node;
    
    // Busca nó anterior
    auto node_prev = chek_points(prev);  
    if (prev == point)
        // Se não existe nó anterior (ex: início), g = 0
        node.g = 0;
    else
        node.g = node_prev->g + 1;  // custo acumulado
    
    node.point = point;
    node.previos_point = prev;

    // Calcular heurística h
    node.h = heuristic(point, goal);

    // Calcular f = g + h
    node.f = node.g + node.h;

    return node;
}


void Astart::node_espand(s_node node,cv::Point end)
{
	t_node node_1,node_2,node_3,node_4;
	cv::Point p1,p2,p3,p4;
	
	p1 = node.point;
	p2 = node.point;
	p3 = node.point;
	p4 = node.point;
	p1.x++;
	p2.x--;
	p3.y++;
	p4.y--;
        node_1 = create_node(p1, node.point, end);
        node_2 = create_node(p2, node.point, end);
        node_3 = create_node(p3, node.point, end);
        node_4 = create_node(p4, node.point, end);

}


bool Astart::start_al(cv::Point start, cv::Point end)
{
	t_node node;
	t_node copy;
	
	node  = create_node(start, start, end);
	copy = node;
	_open.emplace_front(node);

	for(t_node& node : _open)
	{
		std::cout << node.point << std::endl;
	}

	std::cout << _open.begin()->point << std::endl;

	
	while (!_open.empty())
	{
		_open.sort([](const t_node& a,const  t_node& b) {
        	return a.f < b.f;  // Ordena por menor f
   		});
		node_espand(*_open.begin(),*_open.end());


	}	

	return (false);
}

